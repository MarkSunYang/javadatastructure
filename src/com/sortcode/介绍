1. 内部排序
数据加载到内存中进行排序

插入 | 直接插入排序
     | 希尔排序
选择 | 简单选择排序
     | 堆排序
交换 | 冒泡排序
     | 快速排序

归并
基数排序

2. 外部排序
数据量过大，需要借助外部存储进行排序


# 时间复杂度


# 冒泡排序
原始数组：3 9 -1 10 20
第一趟排序
(1) 3 9 -1 10 20 //如果相邻的两个逆序就交换
(2) 3 -1 9 10 20 //
(3) 3 -1 9 10 20
(4) 3 -1 9 10 20
第二趟排序
(1) -1 3 9 10 20
(2) -1 3 9 10 20
(3) -1 3 9 10 20
第三趟排序
(1) -1 3 9 10 20
(2) -1 3 9 10 20
第四趟排序
(1) -1 3 9 10 20
总结：
(1)一共进行数组大小-1次大的循环
(2)每次排序在逐渐减少
(3)如果我们发现在某趟排序中，没有发生一次，则可以结束排序


# 选择排序
第一次从 arr[0]-arr[n-1] 取最小值 与arr[0]交换
第二次从 arr[1]-arr[n-1] 选最小值 与arr[1]交换

初始状态 8 3 2 1 7 4 6 5
第一次 [1 3 2 8 7 4 6 5]
第二次 [1 2 3 8 7 4 6 5]
第三次 [1 2 3 4 7 8 6 5]
第四次 [1 2 3 4 7 8 6 5]
第五次 [1 2 3 4 5 6 8 7]
第六次 [1 2 3 4 5 7 8 6]
第七次 [1 2 3 4 5 6 7 8]

选择排序的思路图解
(1).一共进行数组大小的 length-1次循环
(2).每趟排序的数逐渐减少
(3).假定当前这个数是最小的，如果发现有比这个数更小的，则重新确定最小的数，并得到下标
(4).优化：没有发生交换，可能排序结束了

# 插入排序
把n个待排序的元素看成一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中包含n-1个元素，
排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较

初始状态    [17 3 25 14 20 9]
第一次插入  [3 17 25 14 20 9]
第二次插入  [3 17 25 14 20 9]
第三次插入  [3 14 17 25 20 9]
第四次插入  [3 14 17 20 25 9]
第五次插入  [3 9 14 17 20 25]

插入排序的问题
[2 3 4 5 6 1] 如果顺序是从小到大，如果存在最小的数在最后，则要交换很多次

# 希尔排序
希尔排序也是一种插入排序，是简单插入的改版

[8 9 1 7 2 3 5 4 6 0]
初始增量gap=length/2=5,整个分组被分为5组 [8 3][9 5][1 4][7 6][2 0]
1.希尔排序时，对有序序列在插入时采用交换法，并测试排序速度
2.希尔排序时，对有序序列在插入时采用移动法，并测试排序速度
















