排序：


插入排序：简单插入、希尔排序
交换排序：冒泡、快速
选择排序：简单排序、堆排序
归并排序：
计数排序：多关键字排序

算法稳定性：
1.假定在排序的记录中，存在多个具有相同的关键字记录，若经过排序，这些记录的相对次序保持不变，即在原序列中r[i]=r[j]，
且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这个算法是稳定的，否则


1. 内部排序
数据加载到内存中进行排序

插入 | 直接插入排序
     | 希尔排序
选择 | 简单选择排序
     | 堆排序
交换 | 冒泡排序
     | 快速排序

归并
基数排序

2. 外部排序
数据量过大，需要借助外部存储进行排序


## 时间复杂度


## 冒泡排序
原始数组：3 9 -1 10 20
第一趟排序
(1) 3 9 -1 10 20 //如果相邻的两个逆序就交换
(2) 3 -1 9 10 20 //
(3) 3 -1 9 10 20
(4) 3 -1 9 10 20
第二趟排序
(1) -1 3 9 10 20
(2) -1 3 9 10 20
(3) -1 3 9 10 20
第三趟排序
(1) -1 3 9 10 20
(2) -1 3 9 10 20
第四趟排序
(1) -1 3 9 10 20
总结：
(1)一共进行数组大小-1次大的循环
(2)每次排序在逐渐减少
(3)如果我们发现在某趟排序中，没有发生一次，则可以结束排序


## 选择排序
第一次从 arr[0]-arr[n-1] 取最小值 与arr[0]交换
第二次从 arr[1]-arr[n-1] 选最小值 与arr[1]交换

初始状态 8 3 2 1 7 4 6 5
第一次 [1 3 2 8 7 4 6 5]
第二次 [1 2 3 8 7 4 6 5]
第三次 [1 2 3 4 7 8 6 5]
第四次 [1 2 3 4 7 8 6 5]
第五次 [1 2 3 4 5 6 8 7]
第六次 [1 2 3 4 5 7 8 6]
第七次 [1 2 3 4 5 6 7 8]

选择排序的思路图解
(1).一共进行数组大小的 length-1次循环
(2).每趟排序的数逐渐减少
(3).假定当前这个数是最小的，如果发现有比这个数更小的，则重新确定最小的数，并得到下标
(4).优化：没有发生交换，可能排序结束了

## 插入排序
把n个待排序的元素看成一个有序表和一个无序表，开始时有序表只包含一个元素，无序表中包含n-1个元素，
排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表的排序码进行比较

初始状态    [17 3 25 14 20 9]
第一次插入  [3 17 25 14 20 9]
第二次插入  [3 17 25 14 20 9]
第三次插入  [3 14 17 25 20 9]
第四次插入  [3 14 17 20 25 9]
第五次插入  [3 9 14 17 20 25]

插入排序的问题
[2 3 4 5 6 1] 如果顺序是从小到大，如果存在最小的数在最后，则要交换很多次

## 希尔排序
希尔排序也是一种插入排序，是简单插入的改版

[8 9 1 7 2 3 5 4 6 0]
初始增量gap=length/2=5,整个分组被分为5组 [8 3][9 5][1 4][7 6][2 0]
1.希尔排序时，对有序序列在插入时采用交换法，并测试排序速度
2.希尔排序时，对有序序列在插入时采用移动法，并测试排序速度


## 基数排序
1.将所有待比较数值统一为同样的数位长度，数位较短的数前面补0，然后从最低位开始，一次进行一次排序。
这样从最低位排序一直到最高位排序完，数列就变成一个有序序列。
例如 {53,3,532,748,14,214}
step 不全 {053,003,532,748,014,214}

第一轮：将每个元素的个位数取出，然后将该数放到对应的桶
按照这个桶的顺序（以为数组的下标一次取出数据，放到原来数组）
数组顺序 {542，53，3，14，214，748}
按照桶的顺序（一位数组的下标一次取出数据，放入原来数组）

第二轮： 将每个元素的十位取出，然后放到对应的数组
数组顺序{3,14,214,,542,748,53}

第三轮：按照按照百位
{3,14,214,542,748,53}






