1. 内部排序
数据加载到内存中进行排序

插入 | 直接插入排序
     | 希尔排序
选择 | 简单选择排序
     | 堆排序
交换 | 冒泡排序
     | 快速排序

归并
基数排序

2. 外部排序
数据量过大，需要借助外部存储进行排序


# 时间复杂度


# 冒泡排序
原始数组：3 9 -1 10 20
第一趟排序
(1) 3 9 -1 10 20 //如果相邻的两个逆序就交换
(2) 3 -1 9 10 20 //
(3) 3 -1 9 10 20
(4) 3 -1 9 10 20
第二趟排序
(1) -1 3 9 10 20
(2) -1 3 9 10 20
(3) -1 3 9 10 20
第三趟排序
(1) -1 3 9 10 20
(2) -1 3 9 10 20
第四趟排序
(1) -1 3 9 10 20
总结：
(1)一共进行数组大小-1次大的循环
(2)每次排序在逐渐减少
(3)如果我们发现在某趟排序中，没有发生一次，则可以结束排序


# 选择排序
第一次从 arr[0]-arr[n-1] 取最小值 与arr[0]交换
第二次从 arr[1]-arr[n-1] 选最小值 与arr[1]交换

初始状态 8 3 2 1 7 4 6 5
第一次 [1 3 2 8 7 4 6 5]
第二次 [1 2 3 8 7 4 6 5]
第三次 [1 2 3 4 7 8 6 5]
第四次 [1 2 3 4 7 8 6 5]
第五次 [1 2 3 4 5 6 8 7]
第六次 [1 2 3 4 5 7 8 6]
第七次 [1 2 3 4 5 6 7 8]

选择排序的思路图解
(1).一共进行数组大小的 length-1次循环
(2).每趟排序的数逐渐减少
(3).假定当前这个数是最小的，如果发现有比这个数更小的，则重新确定最小的数，并得到下标
(4).优化：没有发生交换，可能排序结束了


























