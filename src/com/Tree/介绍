树
1. 数组存储的方式 优缺点
2. 链表存储方式的 优缺点

数组扩容：每次在底层都都创建新的数组，然后将原来的数据拷贝，插入新的数据

3. 树的存储方式分析

## 树的常用术语
节点，根节点，父节点，子节点，叶节点，路径，层，子树

## 满二叉树 完全二叉树 平衡二叉树
完全二叉树：
若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。

满二叉树
除最后一层无任何子节点外，每一层上的所有结点都有两个子结点（最后一层上的无子结点的结点为叶子结点）。

## 二叉树
每个节点只能有两个子节点的一种形式称为二叉树
二叉树的子节点分为左节点和右节点
二叉树的所有叶子节点都在最后一层，且节点总数=2^n-1,n为层数，则我们称为满二叉树
完全二叉树

## 二叉树的遍历
前序 父节点 左子树 右子树
中序 左子树 父节点 右子树
后序 左子树 右子树 父节点


# 二叉树的查找
1.请编写前序查找，中序查找和后续查找方法
2.分别使用查找方式查找hero.no=5的节点
3.分析查找的方式比较次数

# 二叉树的删除
1. 叶子节点，删除该节点
2. 非叶子节点，删除该子树
1. 二叉树是单向的，所以我们是判断当前节点的子节点，是否需要删除，而不能判断当前节点
如果当前节点的左子树不为空且左子节点
2. 如果当前节点的左子树不为空且左子节就是要删除的节点，将this.left=null
3. 如果当前节点的右子树不为空且右子节就是要删除的节点，将this.right=null
4. 如果第二步和第三步都没有删除节点，那么需要向左递归
5. 如果左子树没有删除，则应该向右子树递归删除
6. 如果是空树，置空


# 顺序存储二叉树
数组和树可已相互转换

1. 二叉树的节点，要求以数组的方式来存放[1,2,3,4,5,6,7]
2. 要求在遍历数组arr时，仍然可以以前序中序后续遍历的方式完成节点遍历
3. 顺序存储一般考虑完全二叉树
第n个元素的左节点为2*n+1
第n个元素的右节点为2*n+2
第n个元素的父节点为(n-1)/2


## 线索化二叉树
1. n个节点的二叉树链表中含有n+1个空指针域，利用二叉节点的空指针域，存放只想节点在某种遍历次序下的前序和后继节点的指针
思路分析：

## 树结构的实际应用

1. 堆排序
堆排序是利用堆这种数据结构设计的排序算法，堆排序是一种选择排序，是不稳定排序
堆是具有以下性质的二叉树：

大顶堆： 每个节点的值都大于或等于其左右孩子节点的值

小顶堆：每个节点的值都小于或等于其左右孩子节点的值

1. 将堆排序序列构造成一个大顶堆
2. 整个排序的最大值就是堆顶的根节点
3. 将其与末尾元素进行交换，此时末尾就是最大值
4. 将n-1个元素构造成一个堆，这样得到n个元素的次小值

大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]
小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]

堆排序的基本思想是：
将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。
将其与末尾元素进行交换，此时末尾就为最大值。
然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了


赫夫曼树
给定n个权值作为n个叶子节点，构造一颗二叉树，若该树的带权路径长度wpl达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树
哈夫曼树是带权路径长度最短的树，权值较大的节点离根较近。
def:路径长度,节点的权，带权路径长度

1. 路径和路径长度，在一棵树中，从一个节点往下可以达到的孩子或孙子节点的通路，称为路径，通路中分支的数目称为路径长度
若规定根节点的层数为1，则从根节点到L层节点的路径长度为L-1
2. 节点的权及带权路径长度：若将树种节点赋给一个
wpl： 树的带权路径长度
wpl最小的就是哈弗曼树

哈夫曼树创建思路图解

构建哈夫曼树的步骤：
1.从小到大进行排序，将每个数据，每一个数据都是一个节点，每个节点都可看成是一颗最简单的二叉树
2.取出根节点带权值最小的两颗二叉树
3.组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
4.再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，知道数列中所有的数据都被处理，就得到一颗赫夫曼树

如何构建一颗赫夫曼树？
{13,7,8,3,29,6,1}要求转成一颗哈夫曼树
排序，{1,3,6,7,8,13,29}


Step1: 1 3 构成一颗二叉树
    4
 1      3
Step2:
        10
    4       6
 1      3
Step3:
    15
 7      8
Step4:




二叉排序树
{7,3,10,12,5,1,9}
高效的完成数据的查询和添加
二叉排序树：BST对于二叉排序的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子几点比当前节点的值大
如果有相同的值，可以将该节点放在左子节点或右子节点

树存储方式分析：






















