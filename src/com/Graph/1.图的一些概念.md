# 图
* 生活中发生的问题可以转化成图
* 介绍一些算法解决常见的图论问题
* 指出适当选择数据结构可极大的降低这些算法的运行时间
* 介绍一个被深度优先搜索的技巧

## 1.定义
图是一种数据结构，可有零个或多个相邻元素。两个节点之间的连接成为边。
图由若干个 顶点 的 集 和 边的集构成
图
顶点：就是节点
边：两个节点之间连线
有向图
邻接
权
路径：
圈
带权图：也叫网

节点 vertex 与 边edge 
图的表示：邻接矩阵和邻接表
    * 有向图和无向图
    * 无向图是一种特殊的有向图
    * 有权图和无权图
图的遍历：
DFS BFS 常见可以解决的问题
通分量 Flood Fill 寻路 走迷宫 迷宫生成 无权图的最短路径 环的判断
最小生成树问题（Minimum Spanning Tree） Prim Kruskal
最短路径问题(Shortest Path) Dijkstra Bellman-Ford
拓扑排序(Topological sorting)


## 2.为什么要有图
线性表：局限于一个直接前驱和一个直接后继的关系
树：树也只能有一个直接前驱也就是父节点
多对多关系的时候就用到了图

## 3.图的表示方式
图的表示方式有两种：二维数组（邻接矩阵）；链表表示（邻接表）
邻接矩阵：
邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在的，会造成空间一定的损失
邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间浪费，邻接表由数组+链表组成

0 1->2->3->4 标号为0的顶点与其他顶点相连
1 0->4
2 0->4->5
3 0->5
4 0->1>2->5
5 2->3->4

## 图的快速入门案例
思路分析：存储顶点 string 类型 ArrayList 集合，保存矩阵，int[][] edges

## 图的深度优先 DFS deep first search
1. 深度优先遍历，从初始访问节点出发，深度优先遍历首先访问第一个邻节点，
然后再以这个被访问的邻节点作为被访问的初始节点，访问他的第一个邻接点
2.深度优先显然是一个递归的过程

深度优先遍历步骤：
1. 访问初始节点V，并标记节点v为已访问
2. 查找节点v的第一个邻接点w
3. 若w存在，则继续执行4，如果w不存在，则回到第一步，将从v的下一个节点继续
4. 如果w未被访问，对w进行深度优先递归
5. 查找节点的w邻接节点的下一个邻接点

## 图的广度优先 
图的广度优先搜索 BFS broad first search
1.访问初始节点v,点v标记为已访问，
2.节点v入队列
3.当队列非空时，继续执行，否则算法结束


## 最小生成树
给定一个带权的无向连通图，如何选取一颗生成树，使树上所有边上的总和为最小，这叫最小生成树
1.N 个顶点，一定有N-1条边
2.包含全部顶点
3.N-1条边都在图中
prim和kruskal实现原理相似，一个通过边，一个通过顶点实现



### prim 普利姆算法  最短路径

### Kruskal 算法 克鲁斯卡尔算法





















